"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var extend = require("extend");
var isStream = require("isstream");
var common_1 = require("../lib/common");
var SynthesizeStream = require("../lib/synthesize-stream");
var GeneratedTextToSpeechV1 = require("./v1-generated");
var TextToSpeechV1 = /** @class */ (function (_super) {
    __extends(TextToSpeechV1, _super);
    function TextToSpeechV1(options) {
        var _this = _super.call(this, options) || this;
        /**
         * Repair the WAV header of an audio/wav file in Stream format.
         * The Stream is read into memory, then the data is repaired and returned as a Buffer.
         *
         * @param {Buffer} wavFileAsStream - wave audio as a stream
         * @return {Buffer} wavFileData - a Buffer with the correct header
         */
        _this.repairWavHeaderStream = function (wavFileAsStream) {
            // in case of accidentally calling the wrong method
            if (!isStream(wavFileAsStream)) {
                return Buffer.isBuffer(wavFileAsStream)
                    ? Promise.resolve(_this.repairWavHeader(wavFileAsStream))
                    : Promise.reject('Expected input data to be a Stream.');
            }
            var buffers = [];
            return new Promise(function (resolve, reject) {
                // stream info to the buffer
                wavFileAsStream.on('data', function (data) {
                    buffers.push(data);
                });
                wavFileAsStream.on('end', function () {
                    resolve(_this.repairWavHeader(Buffer.concat(buffers)));
                });
                wavFileAsStream.on('error', function (err) {
                    reject(err);
                });
            });
        };
        /**
         * Repair the WAV header of an audio/wav file.
         *
         * @param {Buffer} wavFileData - Wave audio - will be edited in place and returned
         * @return {Buffer} the original Buffer, with the correct header
         */
        _this.repairWavHeader = function (wavFileData) {
            var totalBytes = wavFileData.length;
            // bytes 4-8 in header give the total file size,
            // after the first 8 bytes
            // this is a reliable constant
            var chunkSize = totalBytes - 8;
            wavFileData.writeInt32LE(chunkSize, 4);
            // the first subchunk is at byte 12, the fmt subchunk
            // this is the only other reliable constant
            var chunkIdOffset = 12;
            var fieldSize = 4;
            // every subchunk has a 4 byte id followed by a 4 byte size field
            var chunkSizeOffset = chunkIdOffset + fieldSize;
            var subchunk2sizeLocation = 0;
            // initialize values to hold data of each chunk we come across
            var tempChunkID = '';
            var tempChunkSize = 0;
            while (tempChunkID !== 'data') {
                if (chunkSizeOffset + fieldSize > totalBytes) {
                    break;
                }
                tempChunkID = wavFileData
                    .slice(chunkIdOffset, chunkIdOffset + fieldSize)
                    .toString('ascii');
                tempChunkSize = wavFileData.readInt32LE(chunkSizeOffset);
                // save the location of the data size field
                if (tempChunkID === 'data') {
                    subchunk2sizeLocation = chunkSizeOffset;
                }
                // skip over all the data in the temp chunk
                chunkIdOffset = chunkSizeOffset + fieldSize + tempChunkSize;
                chunkSizeOffset = chunkIdOffset + fieldSize;
            }
            var subchunk2size = totalBytes - subchunk2sizeLocation - fieldSize;
            // update the size of the audio data and return
            wavFileData.writeInt32LE(subchunk2size, subchunk2sizeLocation);
            return wavFileData;
        };
        return _this;
    }
    /**
     * Use the synthesize function with a readable stream over websockets
     *
     * @param {Object} params The parameters
     * @return {SynthesizeStream}
     */
    TextToSpeechV1.prototype.synthesizeUsingWebSocket = function (params) {
        var streamParams = extend(params, {}, {
            // pass the Authenticator to the SynthesizeStream object
            authenticator: this.getAuthenticator(),
            serviceUrl: this.baseOptions.serviceUrl,
            // if the user configured a custom https client, use it in the websocket method
            // let httpsAgent take precedence, default to null
            agent: this.baseOptions.httpsAgent || this.baseOptions.httpAgent || null,
            // allow user to disable ssl verification when using websockets
            disableSslVerification: this.baseOptions.disableSslVerification
        });
        // include analytics headers
        var sdkHeaders = common_1.getSdkHeaders('text_to_speech', 'v1', 'synthesizeUsingWebSocket');
        streamParams.headers = extend(true, sdkHeaders, streamParams.headers);
        return new SynthesizeStream(streamParams);
    };
    return TextToSpeechV1;
}(GeneratedTextToSpeechV1));
module.exports = TextToSpeechV1;
